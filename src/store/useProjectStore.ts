import { create } from 'zustand';
import { Project, Asset, ProjectStatus, Festival, Submission } from '@/types';
import { supabase } from '@/lib/supabase';

interface ProjectState {
    projects: Project[];
    assets: Asset[];
    festivals: Festival[];
    submissions: Submission[];
    isLoading: boolean;
    error: string | null;

    // Actions
    fetchInitialData: () => Promise<void>;

    setProjects: (projects: Project[]) => void;
    addProject: (project: Project) => Promise<void>;
    updateProject: (id: string, data: Partial<Project>) => Promise<void>;
    deleteProject: (id: string) => Promise<void>;
    setCurrentProject: (id: string | null) => void;

    addAsset: (asset: Asset) => Promise<void>;
    updateAsset: (id: string, data: Partial<Asset>) => Promise<void>;
    deleteAsset: (id: string) => Promise<void>;

    addSubmission: (submission: Submission) => Promise<void>;
    updateSubmission: (id: string, data: Partial<Submission>) => Promise<void>;
    deleteSubmission: (id: string) => Promise<void>;
}

export const useProjectStore = create<ProjectState>((set, get) => ({
    projects: [],
    assets: [],
    festivals: [],
    submissions: [],
    isLoading: false,
    error: null,

    fetchInitialData: async () => {
        set({ isLoading: true, error: null });
        try {
            const [pRes, aRes, fRes, sRes] = await Promise.all([
                supabase.from('projects').select('*'),
                supabase.from('assets').select('*'),
                supabase.from('festivals').select('*'),
                supabase.from('submissions').select('*')
            ]);

            if (pRes.error) throw pRes.error;
            if (aRes.error) throw aRes.error;
            if (fRes.error) throw fRes.error;
            if (sRes.error) throw sRes.error;

            // Transform data if necessary (e.g. mapping DB columns to types if they differ)
            // Assuming 1:1 mapping for now based on schema.sql matching types.ts

            set({
                projects: pRes.data as Project[],
                assets: aRes.data as Asset[],
                festivals: fRes.data as Festival[],
                submissions: sRes.data as Submission[],
                isLoading: false
            });
        } catch (error: any) {
            console.error('Error fetching data:', error);
            set({ error: error.message, isLoading: false });
        }
    },

    setProjects: (projects) => set({ projects }),
    setCurrentProject: (id) => { }, // Not really used in this implementation, can be removed or kept as placeholder

    addProject: async (project) => {
        // Remove ID if it's generated by DB, or keep if we generate UUIDs client-side.
        // Supabase gen_random_uuid() handles it if we omit ID.
        // But our types require ID. Let's assume we generate UUID client-side or handle the response.
        // For simplicity, let's let Supabase generate ID and we fetch it back, OR we generate it here.

        // Actually, let's strip ID if it's a placeholder and let DB handle it, then update store.
        // But for now, let's assume the passed project object has a valid UUID or we accept what DB gives.

        const { data, error } = await supabase.from('projects').insert(project).select().single();
        if (error) {
            console.error('Error adding project:', error);
            return;
        }
        set((state) => ({ projects: [...state.projects, data as Project] }));
    },

    updateProject: async (id, data) => {
        const { error } = await supabase.from('projects').update(data).eq('id', id);
        if (error) {
            console.error('Error updating project:', error);
            return;
        }
        set((state) => ({
            projects: state.projects.map((p) => p.id === id ? { ...p, ...data } : p)
        }));
    },

    deleteProject: async (id) => {
        const { error } = await supabase.from('projects').delete().eq('id', id);
        if (error) {
            console.error('Error deleting project:', error);
            return;
        }
        set((state) => ({
            projects: state.projects.filter((p) => p.id !== id)
        }));
    },

    addAsset: async (asset) => {
        const { data, error } = await supabase.from('assets').insert(asset).select().single();
        if (error) {
            console.error('Error adding asset:', error);
            return;
        }
        set((state) => ({ assets: [...state.assets, data as Asset] }));
    },

    updateAsset: async (id, data) => {
        const { error } = await supabase.from('assets').update(data).eq('id', id);
        if (error) {
            console.error('Error updating asset:', error);
            return;
        }
        set((state) => ({
            assets: state.assets.map((a) => a.id === id ? { ...a, ...data } : a)
        }));
    },

    deleteAsset: async (id) => {
        const { error } = await supabase.from('assets').delete().eq('id', id);
        if (error) {
            console.error('Error deleting asset:', error);
            return;
        }
        set((state) => ({
            assets: state.assets.filter((a) => a.id !== id)
        }));
    },

    addSubmission: async (submission) => {
        const { data, error } = await supabase.from('submissions').insert(submission).select().single();
        if (error) {
            console.error('Error adding submission:', error);
            return;
        }
        set((state) => ({ submissions: [...state.submissions, data as Submission] }));
    },

    updateSubmission: async (id, data) => {
        const { error } = await supabase.from('submissions').update(data).eq('id', id);
        if (error) {
            console.error('Error updating submission:', error);
            return;
        }
        set((state) => ({
            submissions: state.submissions.map((s) => s.id === id ? { ...s, ...data } : s)
        }));
    },

    deleteSubmission: async (id) => {
        const { error } = await supabase.from('submissions').delete().eq('id', id);
        if (error) {
            console.error('Error deleting submission:', error);
            return;
        }
        set((state) => ({
            submissions: state.submissions.filter((s) => s.id !== id)
        }));
    },
}));
